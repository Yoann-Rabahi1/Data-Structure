#include <stdio.h>
#include "slist.h"

int main(void) {
    // nœud créé à la main
    SNode n1;
    n1.data = 0;
    n1.next = NULL;
    printf("n1.data = %d\n", n1.data);

    // nœud via la fabrique (pointeur)
    SNode *n2 = ds_slist_create_node(20);
    printf("n2->data = %d\n", n2->data);

    // pointeur vers n2
    SNode *pnode = n2;
    printf("pnode->data = %d\n", pnode->data);

    printf("'''''''''''''''''''''''''''''''''''''''''''''''''''''''''");

    // liste 1 : init sur variable
    SList L;
    ds_slist_init(&L);

    // liste 2 : création par valeur
    SList L2 = ds_slist_create();
    (void)L2; // évite un warning si non utilisé

    printf("'''''''''''''''''''''''''''''''''''''''''''''''''''''''''");

    // insertions
    ds_slist_insert_head(&L, 10);
    ds_slist_insert_head(&L, 20);
    ds_slist_insert_head(&L, 30);
    ds_slist_insert_tail(&L, 100);
    ds_slist_insert_tail(&L, 200);

    // affichages
    ds_slist_print(&L);
    ds_slist_print_v1(&L);

    return 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



// slist.c
#include <stdio.h>   // printf
#include <stdlib.h>  // malloc, free
#include "slist.h"

SNode *ds_slist_create_node(int data) {
    // allocation d'un maillon
    SNode *pnode = (SNode *)malloc(sizeof(SNode));
    if (!pnode) return NULL;
    pnode->data = data;
    pnode->next = NULL;
    return pnode;
}

void ds_slist_init(SList *plist) {
    // tête vide
    plist->head = NULL;
}

SList ds_slist_create(void) {
    // liste vide par valeur
    SList list;
    list.head = NULL;
    return list;
}

int ds_slist_is_empty(const SList *plist) {
    // vrai si tête nulle
    return plist->head == NULL;
}

int ds_slist_insert_head(SList *plist, int value) {
    // insère en tête
    SNode *new_node = ds_slist_create_node(value);
    if (!new_node) return 0;
    new_node->next = plist->head;
    plist->head = new_node;
    return 1;
}

int ds_slist_insert_tail(SList *plist, int value) {
    // insère en fin
    SNode *new_node = ds_slist_create_node(value);
    if (!new_node) return 0;
    if (ds_slist_is_empty(plist)) {
        plist->head = new_node;
    } else {
        SNode *cur = plist->head;
        while (cur->next) cur = cur->next;
        cur->next = new_node;
    }
    return 1;
}

void ds_slist_print(const SList *plist) {
    // parcours itératif
    const SNode *cur = plist->head;
    printf("[");
    while (cur) {
        printf("%d", cur->data);
        if (cur->next) printf(" -> ");
        cur = cur->next;
    }
    printf("]\n");
}

void ds_slist_print_rec(const SNode *pnode) {
    // affichage récursif d'une chaîne
    if (pnode) {
        printf("%d", pnode->data);
        if (pnode->next) printf(" -> ");
        ds_slist_print_rec(pnode->next);
    }
}

void ds_slist_print_v1(const SList *plist) {
    // wrapper récursif
    printf("[");
    ds_slist_print_rec(plist->head);
    printf("]\n");
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef SD_LINKEDLIST_SLIST_H
#define SD_LINKEDLIST_SLIST_H

#include <stddef.h> // NULL

// maillon
typedef struct SNode {
    int data;
    struct SNode *next;
} SNode;

// liste
typedef struct SList {
    SNode *head;
} SList;

// API
SNode *ds_slist_create_node(int data);

void   ds_slist_init(SList *list);
SList  ds_slist_create(void);

int    ds_slist_is_empty(const SList *plist);
int    ds_slist_insert_head(SList *list, int value);
int    ds_slist_insert_tail(SList *list, int value);

void   ds_slist_print(const SList *plist);
void   ds_slist_print_rec(const SNode *pnode);
void   ds_slist_print_v1(const SList *plist);

#endif // SD_LINKEDLIST_SLIST_H